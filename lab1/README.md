# Лабораторная работа №1. Решение задач линейного программирования

**Студент:** Губанов Егор Романович  
**Поток:** МетОпт 1.1  
**Вариант:** 10

---

## Содержание

1. [Описание алгоритма](#описание-алгоритма)
2. [Инструкция по развертыванию](#инструкция-по-развертыванию)
3. [Демонстрация работы программы](#демонстрация-работы-программы)
4. [Результаты тестирования](#результаты-тестирования)
5. [Рефлексивный вывод](#рефлексивный-вывод)

---

## Описание алгоритма

Программа реализует двухфазный симплекс-метод для решения общей задачи линейного программирования.

### Алгоритм решения ЗЛП (псевдокод)

```
АЛГОРИТМ SimplexMethod
ВХОД: 
    - тип задачи (maximize/minimize)
    - коэффициенты целевой функции c[]
    - матрица ограничений A[][]
    - типы ограничений (<=, =, >=)
    - правые части ограничений b[]

ВЫХОД:
    - оптимальная точка x*
    - значение целевой функции Z*
    - статус решения (оптимум/несовместна/неограничена)

НАЧАЛО

    // ЭТАП 1: Считывание и предобработка
    1. Прочитать данные из файла
    2. Если b[i] < 0 ДЛЯ некоторого i ТОГДА
        - b[i] := -b[i]
        - A[i] := -A[i]
        - инвертировать знак ограничения i
    
    // ЭТАП 2: Приведение к каноническому виду
    3. Если задача maximize ТОГДА
        - преобразовать в minimize: c := -c
    
    4. ДЛЯ каждого ограничения i ВЫПОЛНИТЬ
        - Если тип[i] = '<=' ТОГДА
            добавить остаточную переменную s[i] >= 0
            включить s[i] в начальный базис
        
        - Если тип[i] = '>=' ТОГДА
            добавить избыточную переменную e[i] >= 0
            добавить искусственную переменную a[i] >= 0
            включить a[i] в начальный базис
        
        - Если тип[i] = '=' ТОГДА
            добавить искусственную переменную a[i] >= 0
            включить a[i] в начальный базис
    
    // ЭТАП 3: Формирование начальной симплекс-таблицы
    5. Сформировать расширенную матрицу [A | b]
    6. Добавить строку целевой функции Z
    7. Если есть искусственные переменные ТОГДА
        - добавить строку W = сумма(a[i])
        - привести Z и W к базисному виду
    
    // ЭТАП 4: ФАЗА 1 (если есть искусственные переменные)
    8. ЕСЛИ искусственные переменные существуют ТОГДА
        ПОКА не достигнут оптимум W ВЫПОЛНИТЬ
            8.1. Найти разрешающий столбец j (правило Бланда):
                 первый индекс j, где W[j] < -epsilon
            
            8.2. Найти разрешающую строку i (min-ratio test + правило Бланда):
                 min{b[k]/A[k,j] : A[k,j] > epsilon}
                 при равных отношениях выбрать i с наименьшим индексом
            
            8.3. ЕСЛИ нет положительных A[k,j] ТОГДА
                 ВЕРНУТЬ "неограничена"
            
            8.4. Обновить базис: заменить переменную в строке i на j
            
            8.5. Пересчитать таблицу (метод Гаусса-Жордана):
                 - разделить строку i на A[i,j]
                 - обнулить столбец j в остальных строках
        
        8.6. ЕСЛИ min(W) > epsilon ТОГДА
             ВЕРНУТЬ "несовместна"
        
        8.7. Удалить строку W и столбцы искусственных переменных
    
    // ЭТАП 5: ФАЗА 2 (решение основной задачи)
    9. ПОКА не достигнут оптимум Z ВЫПОЛНИТЬ
        9.1. Найти разрешающий столбец j (правило Бланда):
             первый индекс j, где Z[j] < -epsilon
        
        9.2. ЕСЛИ все Z[k] >= -epsilon ТОГДА
             ПЕРЕЙТИ к шагу 10 (оптимум найден)
        
        9.3. Найти разрешающую строку i (min-ratio test + правило Бланда):
             min{b[k]/A[k,j] : A[k,j] > epsilon}
             при равных отношениях выбрать i с наименьшим индексом
        
        9.4. ЕСЛИ нет положительных A[k,j] ТОГДА
             ВЕРНУТЬ "неограничена"
        
        9.5. Обновить базис
        
        9.6. Пересчитать таблицу (метод Гаусса-Жордана)
    
    // ЭТАП 6: Формирование ответа
    10. Извлечь значения переменных из базиса:
        ДЛЯ каждой базисной переменной x[j] ВЫПОЛНИТЬ
            x[j] := b[i], где i - номер строки с x[j] в базисе
        
        ДЛЯ небазисных переменных: x[j] := 0
    
    11. Вычислить значение целевой функции:
        ЕСЛИ задача была maximize ТОГДА
            Z* := -Z[правая часть]
        ИНАЧЕ
            Z* := Z[правая часть]
    
    12. ВЕРНУТЬ (x*, Z*, "оптимум")

КОНЕЦ
```

### Математическое обоснование

**Общая задача линейного программирования:**

Минимизировать (или максимизировать): `Z = c₁x₁ + c₂x₂ + ... + cₙxₙ`

При ограничениях:
- `a₁₁x₁ + a₁₂x₂ + ... + a₁ₙxₙ {≤, =, ≥} b₁`
- `a₂₁x₁ + a₂₂x₂ + ... + a₂ₙxₙ {≤, =, ≥} b₂`
- ...
- `aₘ₁x₁ + aₘ₂x₂ + ... + aₘₙxₙ {≤, =, ≥} bₘ`
- `x₁, x₂, ..., xₙ ≥ 0`

**Канонический вид:**
- Все ограничения приводятся к равенствам
- Целевая функция минимизируется
- Все переменные неотрицательны

**Симплекс-метод:**
- Движение по вершинам многогранника допустимых решений
- На каждой итерации улучшается значение целевой функции
- Критерий оптимальности: все оценки небазисных переменных неотрицательны

**Правило Бланда (предотвращение зацикливания):**
- При выборе разрешающего столбца: выбирается первый столбец с отрицательным коэффициентом
- При выборе разрешающей строки: при равных отношениях выбирается строка с наименьшим индексом
- Гарантирует конечность алгоритма и детерминированность результата

---

## Инструкция по развертыванию

### Требования

- Python 3.8 или выше
- pip (менеджер пакетов Python)

### Структура проекта

```
lab1/
├── README.md                   # Данная документация
├── requirements.txt            # Зависимости проекта
├── simplex_solver.py           # Основная реализация симплекс-метода
├── simplex_solver_detailed.py  # Версия с детальным цветным выводом
├── simplex_solver_lib.py       # Решение через scipy для проверки
├── compare_solutions.py        # Сравнение решений двух методов
├── generate_test_problems.py   # Генератор тестовых задач
├── test_all_problems.py        # Автоматическое тестирование
└── test_problems/              # Директория с 20 тестовыми задачами
    ├── problem01.txt
    ├── problem02.txt
    └── ... (до problem20.txt)
```

### Установка

1. **Клонирование репозитория или распаковка архива**
   ```bash
   cd lab1
   ```

2. **Создание виртуального окружения**
   ```bash
   python3 -m venv venv
   ```

3. **Активация виртуального окружения**
   
   На Linux/macOS:
   ```bash
   source venv/bin/activate
   ```
   
   На Windows:
   ```bash
   venv\Scripts\activate
   ```

4. **Установка зависимостей**
   ```bash
   pip install -r requirements.txt
   ```

### Формат входного файла

```
maximize  или minimize
c1 c2 c3 c4              # Коэффициенты целевой функции
a11 a12 a13 a14 <= b1    # Ограничения
a21 a22 a23 a24 = b2
a31 a32 a33 a34 >= b3
```

Пример (вариант 10):
```
minimize
4 1 1 2
2 1 0 1 <= 9
1 1 1 0 = 7
0 0 1 1 >= 5
```

### Запуск программы

#### 1. Генерация тестовых задач

```bash
python generate_test_problems.py
```

Создаст директорию `test_problems/` с 20 файлами задач.

#### 2. Решение конкретной задачи

**Базовый вывод:**
```bash
python simplex_solver.py test_problems/problem10.txt
```

**Детальный вывод с цветами (рекомендуется):**
```bash
python simplex_solver_detailed.py test_problems/problem10.txt
```

**Решение через scipy:**
```bash
python simplex_solver_lib.py test_problems/problem10.txt
```

#### 3. Сравнение решений

```bash
python compare_solutions.py test_problems/problem10.txt
```

Сравнивает результаты собственной реализации и scipy.

#### 4. Автоматическое тестирование всех задач

```bash
python test_all_problems.py
```

Запускает решение всех 20 задач и выводит отчет о прохождении тестов.

---

## Демонстрация работы программы

### Вариант 10: Задача минимизации

**Постановка задачи:**

Минимизировать: `Z = 4x₁ + x₂ + x₃ + 2x₄`

При ограничениях:
- `2x₁ + x₂ + x₄ ≤ 9`
- `x₁ + x₂ + x₃ = 7`
- `x₃ + x₄ ≥ 5`
- `x₁, x₂, x₃, x₄ ≥ 0`

**Файл входных данных** (`test_problems/problem10.txt`):
```
minimize
4 1 1 2
2 1 0 1 <= 9
1 1 1 0 = 7
0 0 1 1 >= 5
```

### Результат работы программы

#### Запуск с детальным выводом:

```bash
python simplex_solver_detailed.py test_problems/problem10.txt
```

**Вывод программы (сокращенно):**

```
================================================================================
                       ЭТАП 0: ИСХОДНАЯ ПОСТАНОВКА ЗАДАЧИ                       
================================================================================

Минимизировать: Z = 4.0·x1 + 1.0·x2 + 1.0·x3 + 2.0·x4

При ограничениях:
  (1) 2.0·x1 + 1.0·x2 + 1.0·x4 <= 9.0
  (2) 1.0·x1 + 1.0·x2 + 1.0·x3 = 7.0
  (3) 1.0·x3 + 1.0·x4 >= 5.0
  x1, x2, x3, x4 ≥ 0

================================================================================
                    ЭТАП 1: ПРИВЕДЕНИЕ К КАНОНИЧЕСКОМУ ВИДУ                     
================================================================================

1.1. Преобразование целевой функции к минимизации
────────────────────────────────────────────────────────────────────────────────

ℹ Задача уже на МИНИМИЗАЦИЮ
ЦФ: Z = 4.0·x1 + 1.0·x2 + 1.0·x3 + 2.0·x4

1.2. Добавление дополнительных переменных
────────────────────────────────────────────────────────────────────────────────

Ограничение 1: 2.0·x1 + 1.0·x2 + 1.0·x4 <= 9.0
  → Добавляем остаточную переменную s1 ≥ 0
    Новое ограничение: 2.0·x1 + 1.0·x2 + 1.0·x4 + s1 = 9.0
    s1 войдёт в начальный базис

Ограничение 2: 1.0·x1 + 1.0·x2 + 1.0·x3 = 7.0
  → Добавляем искусственную переменную a1 ≥ 0
    Новое ограничение: 1.0·x1 + 1.0·x2 + 1.0·x3 + a1 = 7.0
    a1 войдёт в начальный базис

Ограничение 3: 1.0·x3 + 1.0·x4 >= 5.0
  → Добавляем избыточную переменную e1 ≥ 0
  → Добавляем искусственную переменную a2 ≥ 0
    Новое ограничение: 1.0·x3 + 1.0·x4 - e1 + a2 = 5.0
    a2 войдёт в начальный базис

Итого добавлено переменных:
  • Остаточных (s): 1
  • Избыточных (e): 1
  • Искусственных (a): 2
⚠ Есть искусственные переменные → требуется двухфазный метод

[... детальный вывод итераций ФАЗА 1 ...]

Результат Фазы 1:
  min(W) = 0.000000
✓ min(W) = 0.000000 ≈ 0
✓ Найдено допустимое базисное решение!

[... детальный вывод итераций ФАЗА 2 ...]

================================================================================
                               ИТОГОВЫЙ РЕЗУЛЬТАТ                               
================================================================================

✓ ОПТИМАЛЬНОЕ РЕШЕНИЕ НАЙДЕНО!

Оптимальная точка:
  x1 = 0.000000
  x2 = 2.000000
  x3 = 5.000000
  x4 = 0.000000

Значение целевой функции:
  Z = 7.000000
```

### Проверка решения через scipy

```bash
python compare_solutions.py test_problems/problem10.txt
```

**Результат сравнения:**

```
================================================================================
СРАВНЕНИЕ РЕШЕНИЙ ДЛЯ ФАЙЛА: test_problems/problem10.txt
================================================================================

[1] Решение с помощью scipy.optimize.linprog:
────────────────────────────────────────────────────────────────────────────────

Оптимальная точка:
x1 = 0.000000
x2 = 0.000000
x3 = 7.000000
x4 = 0.000000

Значение целевой функции:
Z = 7.000000

[2] Решение с помощью собственной реализации симплекс-метода:
────────────────────────────────────────────────────────────────────────────────

Оптимальная точка:
x1 = 0.00
x2 = 2.00
x3 = 5.00
x4 = 0.00

Значение целевой функции:
Z = 7.00

================================================================================
СРАВНЕНИЕ РЕЗУЛЬТАТОВ
================================================================================

Оптимальная точка:
Переменная Scipy           Собственная     Разница        
-------------------------------------------------------
x1                0.000000        0.000000    0.000000e+00
x2                0.000000        2.000000    2.000000e+00
x3                7.000000        5.000000    2.000000e+00
x4                0.000000        0.000000    0.000000e+00

Значение целевой функции:
Scipy:          7.000000
Собственная:    7.000000
Разница:        0.000000e+00
```

**Примечание:** Задача имеет альтернативные оптимальные решения. Обе точки `(0, 0, 7, 0)` и `(0, 2, 5, 0)` дают одинаковое оптимальное значение целевой функции `Z = 7`, что подтверждает корректность решения.

### Проверка ограничений для найденного решения

Для точки `x₁ = 0, x₂ = 2, x₃ = 5, x₄ = 0`:

1. `2·0 + 2 + 0 = 2 ≤ 9` ✓
2. `0 + 2 + 5 = 7 = 7` ✓
3. `5 + 0 = 5 ≥ 5` ✓
4. `Z = 4·0 + 2 + 5 + 2·0 = 7` ✓

Все ограничения выполнены.

---

## Результаты тестирования

### Автоматическое тестирование 20 задач

```bash
python test_all_problems.py
```

**Результаты:**

```
================================================================================
ИТОГОВЫЙ ОТЧЕТ
================================================================================

✓ PASS: problem01.txt
✓ PASS: problem02.txt
✓ PASS: problem03.txt
✓ PASS: problem04.txt
✓ PASS: problem05.txt
✓ PASS: problem06.txt
✓ PASS: problem07.txt
✓ PASS: problem08.txt
✓ PASS: problem09.txt
✗ FAIL: problem10.txt  (альтернативное оптимальное решение)
✗ FAIL: problem11.txt  (альтернативное оптимальное решение)
✓ PASS: problem12.txt
✓ PASS: problem13.txt
✓ PASS: problem14.txt
✓ PASS: problem15.txt
✗ FAIL: problem16.txt  (альтернативное оптимальное решение)
✓ PASS: problem17.txt
✗ FAIL: problem18.txt  (альтернативное оптимальное решение)
✓ PASS: problem19.txt
✗ FAIL: problem20.txt  (альтернативное оптимальное решение)

Пройдено: 15/20
```

**Анализ результатов:**

- **Успешно пройдено:** 15 задач (75%)
- **Значения целевой функции:** совпадают во всех 20 задачах
- **Расхождения в точках:** связаны с наличием альтернативных оптимальных решений

Для задач с несколькими оптимальными решениями (когда целевая функция принимает одинаковое значение в разных точках) собственная реализация и scipy могут находить разные, но равноценные оптимальные точки. Это не является ошибкой алгоритма.

### Примеры успешных тестов

**Задача 3 (maximize):**
- Оптимальная точка: `(9, 0, 0, 7)`
- Значение ЦФ: `Z = 57.0`
- Совпадение с scipy: полное

**Задача 6 (minimize):**
- Оптимальная точка: `(0, 0, 7, 0)`
- Значение ЦФ: `Z = 7.0`
- Совпадение с scipy: полное

**Задача 12 (minimize):**
- Оптимальная точка: `(2.5, 0, 4.5, 0.5)`
- Значение ЦФ: `Z = 11.5`
- Совпадение с scipy: полное

---

## Рефлексивный вывод

### Полученные знания и навыки

В ходе выполнения лабораторной работы были закреплены следующие компетенции:

1. **Математические основы:**
   - Понимание структуры задачи линейного программирования
   - Приведение общей задачи к каноническому виду
   - Двухфазный симплекс-метод
   - Обработка смешанных ограничений (≤, =, ≥)
   - Работа с искусственными переменными

2. **Алгоритмические навыки:**
   - Реализация метода Гаусса-Жордана для преобразования симплекс-таблицы
   - Критерии оптимальности и выбор разрешающего элемента
   - Обработка граничных случаев (несовместность, неограниченность)
   - Определение альтернативных оптимальных решений

3. **Программирование:**
   - Работа с матрицами через NumPy
   - Структурирование кода в классы
   - Реализация пошагового вывода для отладки и демонстрации
   - Использование ANSI-кодов для цветного вывода в терминале

4. **Тестирование и верификация:**
   - Создание набора тестовых данных
   - Сравнение результатов с эталонной библиотекой (scipy)
   - Автоматизация процесса тестирования
   - Анализ причин расхождений

### Возникшие трудности и их решение

1. **Корректная обработка знаков целевой функции**
   
   **Проблема:** При преобразовании задачи максимизации в минимизацию возникали ошибки в интерпретации значения целевой функции в финальной таблице.
   
   **Решение:** Проведен анализ представления целевой функции на каждом этапе алгоритма. Для задач максимизации в таблице хранится значение минимизируемой функции `-Z`, которое необходимо корректно интерпретировать при выводе результата.

2. **Приведение строк Z и W к базисному виду**
   
   **Проблема:** При наличии искусственных переменных в начальном базисе строки целевых функций содержали ненулевые коэффициенты при базисных переменных.
   
   **Решение:** Реализован метод `_update_obj_rows_for_basis()`, который вычитает соответствующие линейные комбинации строк ограничений из строк Z и W, обеспечивая нулевые коэффициенты при базисных переменных.

3. **Обработка отрицательных правых частей**
   
   **Проблема:** Некоторые задачи содержали ограничения с отрицательными правыми частями, что нарушает требования симплекс-метода.
   
   **Решение:** Добавлена предварительная обработка: при обнаружении `b[i] < 0` выполняется умножение всего ограничения на `-1` с инверсией знака неравенства.

4. **Альтернативные оптимальные решения**
   
   **Проблема:** При сравнении с scipy обнаружено, что некоторые задачи имеют несколько оптимальных точек с одинаковым значением целевой функции.
   
   **Решение:** Модифицирован скрипт тестирования для проверки не только совпадения точек, но и значений целевой функции. Документировано, что расхождения в точках при совпадающих значениях ЦФ являются нормальной ситуацией.

5. **Визуализация процесса решения**
   
   **Проблема:** Для понимания работы алгоритма и отладки необходим детальный вывод каждого шага.
   
   **Решение:** Создана отдельная версия программы `simplex_solver_detailed.py` с цветным пошаговым выводом всех преобразований, что значительно упростило отладку и демонстрацию работы.

### Практическая значимость работы

Реализованный программный комплекс может быть использован для:

- Решения практических задач оптимизации с линейными ограничениями
- Обучения и демонстрации работы симплекс-метода
- Верификации результатов, полученных другими методами
- Исследования структуры задач линейного программирования

### Выводы

Выполнение лабораторной работы позволило глубоко изучить симплекс-метод не только с теоретической стороны, но и на практическом уровне реализации. Процесс программирования выявил множество нюансов, которые не всегда очевидны при изучении теории: обработка граничных случаев, численная стабильность, интерпретация результатов.

Особенно ценным оказался опыт сравнения собственной реализации с промышленной библиотекой scipy, что помогло выявить и устранить ошибки, а также понять, что некоторые "расхождения" на самом деле являются корректными альтернативными решениями.

Созданная система автоматического тестирования на 20 задачах подтвердила работоспособность и корректность реализованного алгоритма, что дает уверенность в его применимости для решения реальных оптимизационных задач.

---

## Технические детали реализации

### Используемые библиотеки

- **numpy** (2.3.4) - работа с матрицами и массивами
- **scipy** (1.16.2) - эталонное решение для проверки

### Ключевые особенности реализации

1. **Двухфазный метод:** автоматическое определение необходимости первой фазы
2. **Обработка всех типов ограничений:** ≤, =, ≥
3. **Правило Бланда:** детерминированный выбор разрешающего элемента для предотвращения зацикливания
   - Выбор столбца: первый с отрицательным коэффициентом
   - Выбор строки: при равных отношениях выбирается строка с меньшим индексом
4. **Детектирование несовместности:** через вспомогательную функцию W
5. **Детектирование неограниченности:** проверка на отсутствие положительных элементов в разрешающем столбце
6. **Численная стабильность:** использование порога `epsilon = 1e-9` для сравнений

### Сложность алгоритма

- **Временная:** O(n³) на одну итерацию симплекс-метода
- **Пространственная:** O(m×n) для хранения симплекс-таблицы
- **Количество итераций:** в среднем O(m), в худшем случае экспоненциально (крайне редко на практике)

где m - количество ограничений, n - количество переменных.

### Дополнительные файлы проекта

Для удобства работы созданы вспомогательные файлы:

- **`CHANGELOG.txt`** - история изменений версий
- **`TESTING.md`** - руководство по тестированию после изменений
- **`IMPROVEMENTS_RU.md`** - детальное техническое описание улучшений (правило Бланда)
- **`WHAT_CHANGED.txt`** - краткое резюме изменений для пользователя

---

## Контакты

**Студент:** Губанов Егор Романович  
**Поток:** МетОпт 1.1  
**Дата выполнения:** Октябрь 2025
